本程序实现由下推自动机构造等价的上下文无关文法，接下来请您输入需要进行转化的PDA: 
请输入PDA的状态数目：
请输入PDA的状态集（用空格分隔），以回车结束（如果您输入的是终态接受的PDA，请不要将qe和ql作为状态名称）：
请输入PDA字符的个数
请输入PDA字母表（用空格分隔），请确保您输入的字符不会互为前缀，以回车结束：（如果您输入的是终态接受的PDA，请不要将z1作为栈字符）
请输入PDA的栈符号的个数：
请输入PDA的栈符号集合（用空格分隔），以回车结束：
请输入您即将输入的转移函数的个数:
请输入转移函数，格式为p(当前状态) q(输入字符) u(当前栈顶符号) r(下一个状态) v(输入后栈顶符号)，以回车结束每一个转移函数，请用[empty]表示空字符：
请输入初始状态：
请输入栈起始符：
请输入终止状态数目:
请输入终止状态集合，以空格分隔，以回车结束：
生成的CFG如下所示:
非终结符如下:
[q0, z0, q0]
[q0, z0, q1]
[q0, B, q0]
[q0, B, q1]
[q1, B, q0]
[q1, B, q1]
[q1, z0, q0]
[q1, z0, q1]
终结符如下:
a b 
文法产生式如下:
S->[q0, z0, q0]
S->[q0, z0, q1]
[q0, z0, q0]->b[q0, B, q0][q0, z0, q0]
[q0, z0, q0]->b[q0, B, q1][q1, z0, q0]
[q0, z0, q1]->b[q0, B, q0][q0, z0, q1]
[q0, z0, q1]->b[q0, B, q1][q1, z0, q1]
[q0, B, q0]->b[q0, B, q0][q0, B, q0]
[q0, B, q0]->b[q0, B, q1][q1, B, q0]
[q0, B, q1]->b[q0, B, q0][q0, B, q1]
[q0, B, q1]->b[q0, B, q1][q1, B, q1]
[q0, B, q0]->a[q1, B, q0]
[q0, B, q1]->a[q1, B, q1]
[q0, z0, q0]->[empty]
[q1, B, q1]->b
[q1, z0, q0]->a[q0, z0, q0]
[q1, z0, q1]->a[q0, z0, q1]
文法的起始符如下:
S
